<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>7.28-8.3周记</title>
    <url>/2025/08/03/7.28-8.3%E5%91%A8%E8%AE%B0/</url>
    <content><![CDATA[<div>

</div>
<span id="more"></span>
<p>好吧，的确需要吐嘈一下自己了，上一次正经更新blog还是在寒假，现在已经是大一暑假了。这一年的情况是不太如人意的，归根结底还是我没有重视大学生活和绩点。同时我悟出了一个非常非常重要的道理——骄兵必败！不是玩谐音梗，而是这两个月以来，所有我觉得十拿九稳的事情都失败了，包括考试、比赛还有朋辈辅导员的选取（虽然不是那么重要，但大意失荆州还是很可耻的）。最后不得不叹息一声——这很yanhan了。</p>
<h2 id="学习进展">学习进展</h2>
<p>不说之前的事情了，现在是继续往前看的时候了。这周主要学了一些计算机视觉传统的机器学习模型(原谅我的AI风blog吧)，靠着grok和别人的blog，总算是完全过了一遍常用的东西。顺便看了AlexNet和ResNet的模型，只能说看完我也不知道学了点啥，这样说来我必须记笔记了(当然这就不再AI风了，大纲类的学习可以借助，知识点型的细节就不能了)。</p>
<h2 id="生活吐嘈">生活吐嘈</h2>
<p>好啦顺便吐嘈一下我的眼瞎，周三平老师老早给我回了消息我却始终没有看到......好吧只能说这很yanhan了。</p>
<p>还有每天的锻炼，不说了，回家的基操。就这样吧，不写太多了</p>
<h4 id="ps">PS</h4>
<p>看了一篇文章讲述个体行为"刻板印象"的，感觉就像是在说我一样：具体而言就是说自然界的动物总是在遵循着一套成型的规则，就像老虎会巡视领地捕捉猎物。当它们被关在动物园时，会依旧保持这种习惯去巡视，即使在我们看来毫无作用——我们人也是一样，每天拿起手机想看小说，不知道看啥就是想看，然后觉得索然无趣放下手机又觉得啥也不想干活，于是有刷b站浪费时间，一整天过去回头一想发现自己无所事事。我需要找到一个新的正反馈机制，要不然我会死于空虚的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>dailylife</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to YHFrozen&#39;s Blog</title>
    <url>/2024/11/07/Welcome%20to%20YHFrozen&#39;s%20Blog/</url>
    <content><![CDATA[<figure>
<img src="https://api.xecades.xyz/api?date=2025-01-30&amp;str=Frozen%E7%9A%84%E7%94%9F%E6%97%A5&amp;bilibili=Fro%E8%A8%80%E5%87%BA%E6%B3%95%E9%9A%8F&amp;github=YHFrozen&amp;email=yhfrostan%40outlook.com&amp;qq=3308694224&amp;wechat=fro308694224zen&amp;quote=%E7%A5%9D%E6%9C%8B%E5%8F%8B%E9%80%A2%E8%80%83%E5%BF%85%E8%BF%87&amp;img=2&amp;color=255%2C255%2C255%2C1" alt="" /><figcaption>Hello Everyone!</figcaption>
</figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>dailylife</tag>
      </tags>
  </entry>
  <entry>
    <title>blog搭建(github page、hexo、next)</title>
    <url>/2024/11/17/blog%E6%90%AD%E5%BB%BA-github-page%E3%80%81hexo%E3%80%81next/</url>
    <content><![CDATA[<div>

</div>
<span id="more"></span>
<p>最近花了不少时间建立了自己的个人blog网站，整个过程也遇到了不少麻烦，所以写一篇blog记录一下我建立blog的全过程。事先说明我是在windows11系统上搭建的。</p>
<h3 id="hexo">hexo</h3>
<p>推荐可以参考<a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a>来下载配置。对于hexo,首先需要配置<a href="https://github.com/nvm-sh/nvm">nodejs</a>(放的是windows的推荐下载链接，linux、macOS的链接在hexo官方文档里有显示)和<a href="https://github.com/nvm-sh/nvm">git</a>，这些网上都会有详细的教程而且没有什么bug，所以就不详细写了(当然不是因为博主已经忘记了自己是怎么安装的了啊)，对于git的安装有一篇推荐的<a href="https://blog.csdn.net/mukes/article/details/115693833">文档</a>. 当然安装好git之后还不够，因为我们的网站是要托管在github上的。如果你没有github账号，请你注册一个。之后我们要把自己电脑的ssh key配置到github上，这样我们就可以把本地的仓库提交到github上了。</p>
<h4 id="配置ssh-key">配置ssh key</h4>
<p>(以下操作最好在git bash中运行，因为cmd、powershell可能无法识别你的git命令)</p>
<h5 id="step1.检查主机是否已有ssh-key">step1.检查主机是否已有ssh key</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br><span class="line">//看看是否存在id_rsa和id_rsa.pub文件，当然你也可能跟我一样是id_ed25519</span><br></pre></td></tr></table></figure>
<p>如下图所示即为已存在ssh key <img src="images/blog-building/ssh-key.png" alt=""> 如果存在，直接跳到step3</p>
<h5 id="step2.生成ssh-key">step2.生成ssh key</h5>
<p>如果不存在ssh key，执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</span><br><span class="line">//填你自己注册github的邮箱</span><br></pre></td></tr></table></figure>
<h5 id="step3.获取ssh公钥内容id_rsa.pub">step3.获取ssh公钥内容(id_rsa.pub)</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>当然你直接去到C:.ssh下面用记事本之类的打开文件也可以。</p>
<p>如下图所示，复制内容： <img src="images/blog-building/ssh-pub.png" alt="alt text" /></p>
<h5 id="step4.github上添加公钥">step4.Github上添加公钥</h5>
<p>进入settings <img src="images/blog-building/settings.png" alt="alt text" /> 找到SSH and GPG keys，然后点击New SSH key，把刚才的内容复制上去就好了。</p>
<h5 id="step5.验证">step5.验证</h5>
<p>执行以下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure> 显示如下命令即为设置成功： <img src="images/blog-building/verify.png" alt="alt text" /></p>
<h4 id="安装hexo时需要注意的问题">安装Hexo时需要注意的问题</h4>
<p>(以下的操作推荐可以在vscode中打开hexo的文件夹，使用vscode的终端进行配置，当然你用cmd、powershell也不会有任何问题) 官方文档所给出的安装步骤已经十分详细，但要注意的是在安装Hexo之前最好先给npm换源(nodejs的安装似乎也会出现类似的情况，换源就好了)，否则安装可能会出一些奇怪的问题，比如说一直转圈的杠杠。</p>
<p>换源执行以下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></p>
<p>之后应该就没什么问题了。</p>
<h4 id="建站">建站</h4>
<p>依旧还是说文档很全，当你执行完<code>npm install</code>的命令后，你的网站就已经搭建好了，之后的工作就是去美化你的网站。当然你可以先看一下hexo给大家提供的默认网站的样子。 执行以下操作： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure> 打开<code>http://localhost:4000/</code>你就可以看到当前的网站了，因为我没有保存网站的图片所以就不放了。</p>
<h4 id="配置">配置</h4>
<p>打开根目录(也就是你hexo下载的那个文件夹)，找到_config.yml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: 言出法随的blog</span><br><span class="line">subtitle: &#x27;记一记每日生活和学习的感想唔&#x27;</span><br><span class="line">description: &#x27;每一个不曾起舞的日子，都是对生命的辜负&#x27;</span><br><span class="line">keywords: Frost,dailylife</span><br><span class="line">author: YHFrozen</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;Asia/Shanghai&#x27;</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: http://yhfrozen.github.io</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure>
<p>其中<code>title</code>就是blog的名称，<code>subtitle</code>则是对blog的简短介绍，<code>description</code>可以写自己的座右铭，<code>key words</code>有点类似QQ的标签，<code>author</code>就是你的昵称，<code>language</code>选择<code>zh-CN</code>，<code>timezone</code>选择<code>'Asia/Shanghai'</code>，<code>url</code>就写自己的<code>xxx.github.io</code>.</p>
<h4 id="github">github</h4>
<p>接下来就是该如何把自己的blog托管在github page上面。你当然可以先<code>hexo clean&amp;&amp;hexo g</code>，把生成的<code>public</code>文件夹自己手动push到github上。显然这比较麻烦。幸运的是hexo提供了自动化的工具，你只需要输入<code>hexo d</code>就可以自动帮你把<code>public</code>文件夹上传到github上。 首先我们需要安装这个工具。 安装插件<code>hexo-deployer-git</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure> 然后再_config.yml中找到<code>deploy</code>字段，更改如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:YHFrozen/yhfrozen.github.io.git \\放ssh地址，不要http</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure> 现在只需要一行命令就可以帮你自动上传了 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo d -g # or hexo g -d</span><br></pre></td></tr></table></figure></p>
<h4 id="hexo常见指令与知识">hexo常见指令与知识</h4>
<h5 id="新建文档">新建文档</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new #postname</span><br></pre></td></tr></table></figure>
<p>无需后缀名，hexo会自动在source/_posts下生成相应的<code>.md</code>文档。 例如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;welcome to my blog&quot; //如果有空格或特殊字符需要加上双引号</span><br></pre></td></tr></table></figure></p>
<h5 id="新建页面">新建页面</h5>
<p>hexo 支持建立一些页面，同时也支持对文章进行分类和标签，分类和标签信息都存储在<code>front-matter</code>中。</p>
<h6 id="分类和标签">分类和标签</h6>
<p>hexo提供了<code>tags</code>和<code>categories</code>两种页面(当然远不止这两种)，它们都是如下的结构： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories: #分类</span><br><span class="line">- category1</span><br><span class="line">- category2</span><br><span class="line">#...</span><br><span class="line">tags: #标签</span><br><span class="line">- tag1</span><br><span class="line">- tag2</span><br><span class="line">#...</span><br></pre></td></tr></table></figure> 它们的区别在于<code>categories</code>指的是category1下的category2，是严格的父子关系；而<code>tags</code>指的是既是tag1又是tag2，是并列关系。</p>
<p>你可以通过如下指令来建立页面： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories&amp;&amp;hexo new page tags</span><br></pre></td></tr></table></figure> 在source/下会生成相应的文件夹。以<code>tags</code>为例，打开文件夹后会有一个<code>index.md</code>文档，<code>title</code>可以改成你想要的名称，然后在<code>front-matter</code>中添加<code>type: "tags"</code>,正文留空，就完成了创建。</p>
<h5 id="关于">关于</h5>
<p>同样你可以制作<code>about</code>页面，在前面的基础上在<code>index.md</code>中添加正文部分即可。</p>
<h5 id="常用指令">常用指令</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generater</span><br></pre></td></tr></table></figure>
<p>生成静态文件，可以简写为<code>hexo g</code>，这是更新网站的关键步骤之一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署到github上，可以简写为<code>hexo d</code>，一般和<code>hexo g</code>连用，写成<code>hexo d -g</code>or<code>hexo g -d</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>启动本地服务器，默认网址是<code>http://localhost:4000/</code>，可以简写为<code>hexo s</code>，你可以把它理解为预览。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件(<code>db.json</code>)和已生成的静态文件 (<code>public</code>)。一般在<code>hexo d -g</code>之前都要执行这个命令(<code>hexo s</code>不需要)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft #postname</span><br></pre></td></tr></table></figure>
<p>有的时候你要更新一些文章，但其中一部分还没有做完,所以你就最好在写文章前就把它设置成<code>draft</code>,也就是草稿。它的原理是新文章将建立在 <code>source/_drafts</code> 目录下，因此 <code>hexo generate</code> 并不会将其编译到 <code>public</code> 目录下，所以 <code>hexo deploy</code>也不会将其部署到 GitHub。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo S --draft</span><br></pre></td></tr></table></figure> 本机预览草稿</p>
<h3 id="next">Next</h3>
<p>next的安装推荐参考<a href="https://theme-next.js.org/docs/getting-started/">官方文档</a>，这里就不说了，因为我没有遇到什么bug。</p>
<h5 id="配置-1">配置</h5>
<p>首先打开<code>_config.yml</code>，找到<code>theme</code>字段，把<code>landscape</code>改成<code>next</code>。 之后就是关于<code>_config.next.yml</code>的配置，推荐参考<a href="https://shwstone.cn/2022/07/26/hexo-next%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/?highlight=he">shwstone</a>大佬的blog。</p>
<p>当然由于next的更新迭代，有一些blog的功能在新版下已经变成了其他样子，这个就靠大家自己在网上找找了。</p>
<h6 id="评论系统">评论系统</h6>
<p>我这里只单独说一下评论系统，我用的是gitalk，基于github page搭建的,其余的比如说twikoo之类最近比较火的评论系统大多是基于verel部署的，和github page不太搭。 <a href="https://blog.csdn.net/a171232886/article/details/121206824">gitalk的推荐下载</a></p>
<h4 id="style">style</h4>
<p>有的时候你会发现next给出的一些模块的颜色、字体之类的你不太满意，这个时候你就需要自己去微调。在<code>_config.next.yml</code>下找到<code>custom_file_path</code>字段，将<code>style: source/_data/styles.styl</code>取消注释并建立相应的<code>styles.styl</code>文件。在这个文件里面你需要运用css去编写。例如设置背景： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line"> 	background:url(/images/background.jpg);// 设定背景图片,images同处于source文件夹下</span><br><span class="line"> 	background-repeat: no-repeat;// 设定背景图片非重复填充</span><br><span class="line">          background-attachment:fixed;// 设置背景图片不随页面滚动</span><br><span class="line">          background-position:50% 50%;// 设置背景图片位置</span><br><span class="line">	background-size: cover// 设置保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这就是完全的自定义了，你可以在网站中打开dev tools寻找你想要更改的元素。有一点需要注意的是next似乎给一些元素设置了标签属性，比如<code>.header</code>的颜色的设置的时候就要和下面一样： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 页面头样式属性</span><br><span class="line">.header &#123;</span><br><span class="line">  // 也可以同时定义背景色</span><br><span class="line">  background-color: #800080 none repeat scroll !important;  </span><br><span class="line">  // 透明度</span><br><span class="line">  opacity: 0.85;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当然其他的一些元素就不用加<code>none repeat scroll !important</code>具体的原因是因为不同选择器的优先级不同，<code>!important</code>会设置成强制优先。</p>
<h3 id="域名购买与设置">域名购买与设置</h3>
<p>对于某些人来说，就比如我，会觉得<code>.github.io</code>不符合胃口，就是想要拥有一个自己的域名。这里记录一下我的购买流程。首先我是在<a href="https://wanwang.aliyun.com/?utm_content=se_1018235647">阿里云</a>上购买的，先登录，然后才可以查询域名，进入购买页面。 之后要创建自己的信息模板，需要邮箱、身份证信息。 <img src="images/blog-building/ALI.png" alt="alt text" /> 购买注册之后进行DNS解析(在控制台界面中)，点击云解析DNS， <img src="images/blog-building/dns.png" alt="alt text" /> 点击进入权威域名解析，在操作中选择解析设置，选择第三条(旁边会有提示，A、AAAA、CNAME,选择CNAME),不要选IPv4和IPv6，然后选择www.和@,在记录值中填写你现在的github.io网址。</p>
<p>打开github中的blog仓库，进入Settings选项，点击进入page页面，在最下面的Custom domin中填写你解析好的域名，比如我的就是<code>yhfrozen.fyi</code>，勾选Enforce https项，一分钟左右(可能更少)github会提示你注册成功，这个时候你就真正拥有自己的网站了。 但要注意的是此时你的网站依然托管在github上，也就是说你依旧需要魔法才能登上。如果你想把它搬到内网，你就需要更换国内的服务器，这需要向当地政府做ICP备案.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>应用技术</category>
      </categories>
      <tags>
        <tag>技术杂谈</tag>
        <tag>Bug Report</tag>
      </tags>
  </entry>
  <entry>
    <title>工程伦理复习</title>
    <url>/2024/11/08/%E5%B7%A5%E7%A8%8B%E4%BC%A6%E7%90%86%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<div>

</div>
<span id="more"></span>
<blockquote>
<p>这是关于工程伦理前5章知识点的框架，主要是按照<a href="https://xjtu-ai.github.io/course/lunli/ppt/">工程伦理ppt</a>来梳理的 这篇文章主要还是因为前几章的PPT不太全，所以笔者通过网上的资料查找补全了一下。虽然笔者已经尽量补齐，但估计还是会少不少的内容，推荐大家还是买一个课本吧。</p>
</blockquote>
<h2 id="第一章">第一章</h2>
<ul>
<li>科学技术的定义</li>
<li><ul>
<li>科学的定义</li>
</ul></li>
<li><ul>
<li>技术的定义</li>
</ul></li>
<li>工程伦理的定义：工程相关人员在工程活动中的道德原则和行为规范</li>
</ul>
<ol type="1">
<li><p>工程的基本概念</p>
<ul>
<li><strong>工程的由来</strong></li>
<li><ul>
<li>工程在中国的发展</li>
</ul></li>
<li><ul>
<li>西方"Engineering"的发展</li>
</ul></li>
<li><strong>工程的定义</strong></li>
<li><ul>
<li>广义的工程、狭义的工程(这个是工程的定义)</li>
</ul></li>
<li><strong>工程的过程</strong>：计划-&gt;设计-&gt;建造-&gt;使用-&gt;结束</li>
<li><strong>大工程观</strong>：工程是社会实践活动、多因素制约、复杂的运作体系、复杂的利益系统</li>
<li><ul>
<li>“大工程”中的工程师：需要的能力、“戒指”、“从业仪式”</li>
</ul></li>
</ul></li>
<li><p>工程与社会的关系(<strong>正面作用、负面作用</strong> 这两个我没有在ppt上找到，网上也没有直接的结果，所以放chatgpt的答案，参考即可)</p>
<blockquote>
<p>这个部分我写的很详细的原因是我看下一章的PPT中的已学回顾有提到正面作用和负面作用，但PPT上没有这个部分，所以我就写的详细一些</p>
</blockquote>
<ul>
<li>正面作用:</li>
<li><ul>
<li>促进社会进步和发展 工程技术为社会提供了各种创新和解决方案。例如，建筑工程改善了住房条件，交通工程促进了区域连接和经济流通，信息工程则推动了数字化和信息化社会的发展。工程的创新直接提升了社会的生产力和生活质量。</li>
</ul></li>
<li><ul>
<li>提高生活质量 工程在改善社会基础设施方面发挥重要作用。比如，供水、电力、交通、医疗设施等的建设和维护，为民众的日常生活提供了便利和保障，提升了社会整体的生活水平。</li>
</ul></li>
<li><ul>
<li>增强社会责任感与可持续发展 现代工程技术越来越注重环境保护和资源可持续利用。例如，绿色建筑、可再生能源和环保工程技术的应用帮助社会实现更可持续的经济发展和环境保护目标。工程师在设计和实施这些项目时，通常会考虑到社会和环境的长期影响。</li>
</ul></li>
<li><ul>
<li>促进公平与社会福利 工程项目能够改善贫困地区的基础设施建设，提供教育、医疗等公共资源，帮助社会实现更加平等的发展机会。通过工程技术，很多不发达地区的社会福利得到了显著改善。</li>
</ul></li>
<li>负面作用：</li>
<li><ul>
<li>环境污染与资源浪费 一些工程项目，尤其是传统工业化的工程活动，可能导致严重的环境污染和资源浪费。比如，化石能源的开采、矿山的开发、城市的扩张等，都可能带来空气、水源和土壤的污染，破坏生态平衡，造成生物多样性的丧失。</li>
</ul></li>
<li><ul>
<li>社会不平等与区域发展不均衡 工程项目可能加剧社会的贫富差距和区域发展的不平衡。例如，大规模的基础设施建设通常会集中在经济发达的地区，导致经济落后地区的资源和机会被忽视，进而加剧城乡差距和地区间的不平等。</li>
</ul></li>
<li><ul>
<li>公共安全隐患 工程设计和施工中的失误可能对社会安全带来隐患。例如，建筑质量不合格、交通设施设计不合理、化学品使用不当等，都可能导致灾难性后果。历史上有很多工程失败案例，如桥梁倒塌、建筑物坍塌等，给社会带来巨大的人员伤亡和财产损失。</li>
</ul></li>
<li><ul>
<li>技术失业与社会冲突 新技术的引入和自动化程度的提高，虽然能提高生产效率，但也可能导致传统行业的工人失业。例如，机器人和人工智能的广泛应用可能取代大量的低技能劳动力，造成社会的就业结构变化，并可能引发劳资冲突和社会不稳定。</li>
</ul></li>
<li><ul>
<li>伦理问题与技术滥用 在某些情况下，工程技术可能被滥用或以不道德的方式实施。例如，某些企业为了追求利益最大化，可能在工程设计和施工中忽视社会的伦理需求，如忽略公共安全、侵犯个人隐私等问题。此外，科技在军事、监控等领域的应用，也可能带来伦理上的争议和社会冲突。</li>
</ul></li>
</ul></li>
</ol>
<p>多数工作有好处、每个人都想享受，但不是每个人都能享受； 少数工程有坏处，每个人都想避开，但不是每个人都能避开。</p>
<ul>
<li><p>实际、理论、方法</p></li>
<li><p>生态、伦理、哲学、技术、经济、管理、社会</p>
<p><img src="\images\engineering-link.jpg" alt=""></p></li>
</ul>
<ol type="1">
<li><p>工程伦理教育的历史、现状和意义</p>
<ul>
<li>意义：</li>
<li><ul>
<li><strong>提升工程师的伦理素质</strong>，加强工程从业者的社会责任（问题、意义）</li>
</ul></li>
<li><ul>
<li><strong>推动可持续发展</strong>，促进人与自然的协同进化(问题、意义)</li>
</ul></li>
<li><ul>
<li><strong>协调利益关系</strong>，确保社会稳定与和谐</li>
</ul></li>
</ul></li>
<li><p>工程伦理教育的目标</p>
<ul>
<li>意识、能力、规范</li>
</ul></li>
</ol>
<h2 id="第二章">第二章</h2>
<ol type="1">
<li><p>道德与伦理的理解</p>
<ul>
<li>伦理规范</li>
<li>道德与伦理的联系与区别</li>
</ul></li>
<li><p>伦理学</p>
<ul>
<li>定义</li>
<li>特征</li>
<li>研究任务(描述道德、解释道德、创造道德)</li>
</ul></li>
<li><p>伦理学的主要理论</p></li>
</ol>
<blockquote>
<p>这个ppt上已经比较齐了，但我决定还是把网上的知识点搬过来</p>
</blockquote>
<ul>
<li>功利论：在工程中，“将公众的安全、健康和福祉放在首位”是大多数工程伦理规范的核心原则，功利主义是解释这个原则最直接的方式</li>
<li>义务论或道义论：功利论聚焦于行动的后果，那么义务论则关注的是行为本身。义务论者强调，行为是否正当不应该仅依据行为产生好的后果来判定，行为本身也具有道德意义。</li>
<li>义务论已经在工程伦理学中产生很大影响，尤其是其责任观念对工程伦理规范的制定发挥了重要的作用。</li>
<li>德性论：功利论或义务论以“行为”为中心，关注的是“我应该如何行动？”德性论以“行为者”为中心，关注的是“我应该成为什么样的人？”</li>
<li>伦理学的核心不是“我应该做什么”的问题，而是“我必须具有何种品德的人”的问题。德性论关心的主要是人的内心品德的养成，而不是人外在行为的规则。强调要培养和产生高尚、卓越的人，这种人是出于他们高尚、卓越的品格来自发行动的。</li>
</ul>
<ol start="4" type="1">
<li>需要谨慎处理的四个关系(<strong>如何进行伦理选择</strong> 就答四个关系)</li>
<li>伦理决策</li>
<li>为何存在伦理困境：
<ul>
<li>价值标准的多元化以及现实人类生活本身的复杂性，常常导致具体情境之下道德判断与抉择的两难困境。</li>
</ul></li>
</ol>
<h2 id="第三章">第三章</h2>
<ol type="1">
<li><p>工程伦理问题概述</p>
<ul>
<li>为何会有工程伦理问题(多重风险、行动者网络、两个维度)</li>
<li>主要的工程伦理问题(技术、利益、环境、责任)</li>
<li>特点：历史性(与发展相关)、社会性(多利益主体相关)、复杂性(多影响因素相关)</li>
<li>如何处理工程实践中的伦理问题(何者、何时、三个基本原则、基本思路)</li>
<li><ul>
<li>(网上答案，仅供参考)总体上，工程伦理要将公众的安全，健康，福祉，放在首位，由此出发，处理工程伦理中的问题要坚持以下三个基本原则：人道主义～处理工程与人关系的基本原则，社会公正～处理工程与社会关系的基本原则，人与自然和谐发展～处理工程与自然关系的基本原则。</li>
</ul></li>
</ul></li>
<li><p>环境伦理问题概述</p>
<ul>
<li>工程环境伦理观念的确立(两个方面、两个思路、基本思想、核心问题)</li>
<li>现代工程的环境影响、道德要求、环境价值观与环境伦理原则</li>
<li>工程师的环境伦理</li>
</ul></li>
<li><p>医学伦理问题概述</p></li>
</ol>
<blockquote>
<p>汗流浃背了，PPT上根本没有这个板块</p>
</blockquote>
<h2 id="第四章">第四章</h2>
<blockquote>
<p>这章的PPT太不全了，所以只能按照1234567的顺序直接写了</p>
</blockquote>
<ol type="1">
<li><p>四条底线：法律底线、纪律底线、政策底线、道德底线</p></li>
<li><p>工程风险的来源(三种不确定因素：技术、环境、人为)</p></li>
<li><p>工程风险的可接受性(相对可接受性、等级划分)</p>
<ul>
<li>工程风险可接受性是指人们在生理和心理上对工程风险的承受和容忍程度。美国工程伦理学家哈里斯等把风险定义为“对人的自由或幸福的一种侵害或限制”。美国风险问题专家威廉•W.劳伦斯把风险定义为“对发生负面效果的可能性和强度的一种综合测量”。</li>
<li>安全等级的划分具有非常重要的经济意义。如果把安全等级制定的过高，那么就会造成不必要的浪费； 反之，则会增大工程风险的概率。给出一个符合实际的安全等级是非常有必要的事情。</li>
<li><ul>
<li>功利主义的风险(感觉好像不应该放在这里，但我也不知道放到哪里了):</li>
</ul></li>
<li><ul>
<li><ul>
<li>首先，它不大可能把与各种选择相关的成本和收益都考虑在内。</li>
</ul></li>
</ul></li>
<li><ul>
<li><ul>
<li>其次，把所有的风险和收益都转换为货币数字井非总是可能的。</li>
</ul></li>
</ul></li>
<li><ul>
<li><ul>
<li>第三，在其通常的应用中，这种方法并没有考虑到成本和收益的分配。为了更多人的利益而牺牲了工人患病和死亡的损失，这种风险就被认为是正当的。然而，我们中的大部分人可能会认为，这种对于可接受的风险的表述是不可接受的。</li>
</ul></li>
</ul></li>
<li><ul>
<li><ul>
<li>第四，这种方法没有考虑到人们对技术所带来的风险的知情同意权。大多数人认为，知情同意是使风险合理化的最重要的特征之一。</li>
</ul></li>
</ul></li>
<li>一种可接受的风险指的是这样一种风险，它是通过行使自由和知情同意权而自愿认可的，或者它是得到适当赔偿的，并且它是公正地分配的。(黄金法则——己所不欲，勿施于人)</li>
</ul></li>
<li><p>工程风险的防范与安全(工程质量监理、意外风险控制、事故应急处置)</p></li>
<li><p>工程风险的伦理评估原则(以人为本、整体主义、预防为主、制度约束)</p>
<ul>
<li>ppt上没有以预防为主和制度约束的原则，所以我加在这里：</li>
<li><ul>
<li>预防为主： 要实现从“事后处理”到“事先预防”的转变。坚持“预防为主”的风险评估原则，要做到充分预见工程可能产生的负面影响。工程在设计之初都设定了一些预期的功能，但是在工程的使用中往往会产生一些负面效应。比如设计师为酒店设计旋转门本来可以起到隔离酒店内外温差的环保效果，但是却给残疾人进出酒店带来了障碍。</li>
</ul></li>
<li><ul>
<li>制度约束： 首先，建立健全安全管理的法规体系。安全管理制度主要包括： 安全设备管理、检修施工管理、危险源管理、隐患排查治理、监督检查管理、安全教育培训、事故应急救援、安全分析预警与事故报告、生产安全事故责任追究、安全生产绩效考核与奖励等等。其次，建立并落实安全生产问责机制。企业应建立主要负责人、分管安全生产负责人和其他负责人在各自职责内的安全生产工作责任体系。最后，还要建立媒体监督制度。媒体监督具有事实公开、传播快速、影响广泛、披露深刻等特点。</li>
</ul></li>
</ul></li>
<li><p>工程风险的伦理评估途径(专家评估、社会评估、公众参与)</p></li>
<li><p>工程风险的伦理评估方法(主体、程序、效力)</p>
<ul>
<li><p>工程风险伦理评估的主体 评估主体在工程风险的伦理评估体系中处于核心地位，发挥着主导作用，决定着伦理评估结果的客观有效性和社会公信力。工程风险的伦理评估主体可分为内部评估主体和外部评估主体。内部评估主体指参与工程政策、设计、建设、使用的主体。包括工程师、工人、投资人、管理者和其他利益相关者，他们在工程活动中都是不可或缺的有机组成部分，发挥着不可替代的作用和功能。内部评估主体之间既存在着各种不同形式合作关系，又存在着各种形式的矛盾冲突关系。外部评估主体指工程主体以外的组织和个人。包括专家学者、民间组织、大众传媒和社会公众。比如圆明园防渗工程存在的环境风险问题，首先是由出差到京的兰州学者揭发的，轰动全国的厦门PX工程事件的揭发者也来自大学的教授。</p></li>
<li><p>工程风险伦理评估的程序 第一步是信息公开。非专业人员对工程所负载价值和风险的理解和评价，只能依靠专业人员所传播的信息。第二步是确立利益相关者，分析其中的利益关系。在利益相关者的选择上要坚持周全、准确、不遗漏的原则。第三步是按照民主原则，组织利益相关者就工程风险进行充分的商谈和对话。具有多元价值取向的利益相关者对工程风险具有不同的感知，要让具有不同伦理关系的利益相关者充分表达他们的意见，发表他们的合理诉求，使工程决策在公共理性和专家理性之间保持合理的平衡。如圆明园防渗工程。</p></li>
<li><p>工程风险伦理评估的效力 “效力”是指确定合理的目标并达到该预期目标，收到了理想的效果。效力包括目标确定、实现目标的能力以及目标实现的效果三个核心要素。就工程风险伦理评估的效力而言，其含义是指伦理评估在防范工程风险出现中的效果及其作用。要遵守如下三个原则：</p></li>
<li><ul>
<li>（1） 公平原则。工程风险的承担者和工程成果的收益者往往是不一致的。随着工程后果影响的累积性、长远性和毁灭性风险的增加，对单一工程的后果评价难度也随之增加。</li>
</ul></li>
<li><ul>
<li>（2） 和谐原则。是指一个工程项目只有以实现和谐为目的的时候才是伦理意义上值得期许的工程。首先要做到人与人的和谐、人与社会的和谐。其次要做到人与自然的和谐以及个人内部身心的和谐。</li>
</ul></li>
<li><ul>
<li>（3） 战略原则。要求我们在面对工程风险的时候，要保持审慎的态度，对具体工程风险作出具体分析，不仅对工程本身的目的、手段和后果作具体分析，还要区分工程所处的时空环境。当工程所处的自然和社会环境发生变化时，要及时修正工程发展战略，简言之，就是要做到因地因时制宜，审时度势、与时俱进。</li>
</ul></li>
</ul></li>
<li><p>何为伦理责任(对责任的多重理解、伦理责任的含义)</p></li>
<li><p>工程伦理责任主体</p>
<ul>
<li>工程师个人的伦理责任（狭义的工程伦理）</li>
<li>工程共同体的伦理责任（广义的工程伦理）</li>
</ul></li>
<li><p>工程伦理责任的类型(职业伦理责任、社会伦理责任、环境伦理责任)</p></li>
<li><p>实验室安全事故警示(问题、根源)、</p></li>
<li><p>工程的价值导向性</p></li>
<li><p>工程价值的多元化(工程的科学价值，工程的政治价值，工程的社会价值，工程的文化价值，工程的生态价值) &gt;从这里开始PPT都不太全，所以就没再写，其实写到这里我发现看书就能解决大部分问题了，所以书还是很有必要的</p></li>
<li><p>邻避效应</p></li>
<li><p>公正的含义、四种类型的公正(补偿公正、惩罚公正、分配公正、程序公正)</p></li>
</ol>
<h2 id="第五章">第五章</h2>
<blockquote>
<p>我的评价是PPT最全的一集</p>
</blockquote>
<ol type="1">
<li>可持续发展思想的形成及发展
<ul>
<li>发展是人类社会永恒的主题</li>
<li>可持续发展思想形成的全球背景</li>
<li>可持续发展思想发展的重要里程碑</li>
</ul></li>
<li>可持续发展的内涵
<ul>
<li>基于人口要素、资源要素、环境要素、经济要素、社会要素、要素综合的定义</li>
<li>内涵的具体化——可持续发展目标(2018)</li>
</ul></li>
<li>资源可持续发展
<ul>
<li>资源开发与人类发展</li>
<li>自然资源的主要特性</li>
<li>不可再生资源的可持续利用</li>
<li>可再生资源的可持续利用</li>
</ul></li>
<li>环境可持续发展
<ul>
<li>环境生产力结构</li>
<li>环境保护</li>
<li>生物多样性保护</li>
</ul></li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>复习资料</category>
      </categories>
      <tags>
        <tag>学校课程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉(传统篇)</title>
    <url>/2025/08/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E4%BC%A0%E7%BB%9F%E7%AF%87/</url>
    <content><![CDATA[<div>

</div>
<span id="more"></span>
<p>前言：这篇blog的最初写作目的是为了把cv初步的方法和其代码一同学习，但是后期发现特征提取部分的方法还是过于复杂的，一篇文章写完不太现实。所以决定这篇文章就按照大纲形式收集下cv各个模块的常用方法以及初步代码(不保真)，以做后续查找使用。 PS:主要是机器学习部分的学习，没有涉及深度的内容,深度学习的处理之后会继续写。</p>
<h2 id="图像和视频">图像和视频</h2>
<h3 id="图像的取样和量化">图像的取样和量化</h3>
<p>图像的取样与量化是数字图像处理的基础，用于将连续的现实世界图像转换为离散的数字形式。</p>
<h4 id="取样sampling">取样(Sampling):</h4>
<ul>
<li>定义：将连续的空间信号（如现实世界的图像）分解为离散像素点网络</li>
<li>过程：通过在空间上以固定间隔（分辨率）采集图像的强度值，将连续图像分割为像素网格。例如，一个 1920x1080 的图像表示在水平和垂直方向上分别采样了 1920 和 1080 次。 #### 量化(Quantization):</li>
<li>定义：将连续的像素强度值（通常是光强或颜色值）映射到离散的数值范围。</li>
<li>过程：将像素的强度值（通常为浮点数）离散化为有限的整数级别。例如，8位灰度图像将强度值量化为 0 到 255 的 256 个级别。</li>
<li>影响：量化级别越高，图像的灰度或颜色表现越细腻，但存储需求也增加。过低的量化级别会导致<strong>伪轮廓（False Contouring）</strong>，即图像出现明显的颜色或灰度分层。</li>
<li>数学表示：假设原始强度值范围为<span class="math inline">\([I_{\text{min}}, I_{\text{max}}]\)</span>，量化为 <span class="math inline">\(L\)</span> 级，量化公式为：<span class="math display">\[I_{\text{quantized}} = \text{round}\left(\frac{I - I_{\text{min}}}{I_{\text{max}} - I_{\text{min}}} \cdot (L-1)\right)\]</span> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>,cv2.IMREAD_GRAYSCALE)</span><br><span class="line">levels=<span class="number">16</span> <span class="comment"># 减少灰度级别到16级</span></span><br><span class="line">quantized_img = np.floor_divide(img, <span class="number">256</span> // levels) * (<span class="number">256</span> // levels) <span class="comment"># np.floor_divide 取整 // 除法取整</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="滤波">滤波</h3>
<p>滤波是图像处理中用于增强、平滑或提取特征的操作，通过对图像像素值进行加权运算来实现。</p>
<ul>
<li>定义：滤波通过一个卷积核（滤波器）对图像进行处理，改变像素值以实现平滑、锐化、边缘检测等效果。</li>
<li>类型：
<ul>
<li>低通滤波(<strong>Low-pass Filtering</strong>)：平滑图像，减少噪声。比如说中值滤波、均值滤波、高斯滤波。</li>
<li>高通滤波(<strong>High-pass Filtering</strong>)：突出图像的高频部分，如边缘或细节，常用于边缘检测（如 Sobel 滤波器）。</li>
<li>带通滤波：保留特定频率范围，常用于特征提取。</li>
</ul></li>
<li>实现：通过卷积操作（详见“卷积”部分）将滤波核应用于图像。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blur=cv2.blur(img,(<span class="number">3</span>*<span class="number">3</span>)) <span class="comment"># 均值滤波</span></span><br><span class="line">sobel_x = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># cv2.Sobel(src, ddepth, dx, dy, ksize): 计算 Sobel 边缘。</span></span><br><span class="line"><span class="comment"># - src: 输入图像。</span></span><br><span class="line"><span class="comment"># - ddepth: 输出图像深度（如 cv2.CV_64F 表示 64 位浮点数以保留负值）。</span></span><br><span class="line"><span class="comment"># - dx, dy: x 和 y 方向的导数阶数（dx=1, dy=0 表示水平边缘）。</span></span><br><span class="line"><span class="comment"># - ksize: 核大小（奇数，如 3）。</span></span><br><span class="line"><span class="comment"># - 返回: 边缘强度图像。</span></span><br></pre></td></tr></table></figure>
<h3 id="直方图">直方图</h3>
<p>直方图是统计图像像素强度分布的工具，用于分析图像的亮度或颜色特性。</p>
<ul>
<li><p><strong>定义</strong>：直方图表示图像中每个强度级别（或颜色通道值）的像素数量。</p>
<ul>
<li>对于灰度图像，直方图通常表示 0 到 255 的灰度级别的像素分布。</li>
<li>对于彩色图像，可以分别对 R、G、B 通道生成直方图。</li>
</ul></li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>分析图像的亮度分布（例如，判断图像是否过暗或过亮）。</li>
<li>作为特征用于图像检索或分类。</li>
<li>指导直方图均衡化等增强算法。</li>
</ul></li>
<li><p><strong>计算</strong>：统计每个强度级别的像素数量，绘制为柱状图（或曲线）。</p>
<ul>
<li>数学表示：对于灰度值 iii（0 到 255），直方图 h(i)h(i)h(i) 表示强度值为 iii 的像素数。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算直方图</span></span><br><span class="line">hist = cv2.calcHist([img], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br></pre></td></tr></table></figure> ### 上采样</li>
</ul></li>
<li><p><strong>定义</strong>：增加图像的分辨率（像素数量），通常用于图像放大。</p></li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><strong>插值法</strong>：如最近邻插值、双线性插值或双三次插值（见“插值”部分）。</li>
<li><strong>超分辨率</strong>：使用机器学习模型（如深度卷积网络）预测高分辨率细节。</li>
</ul></li>
<li><p><strong>应用</strong>：</p>
<ul>
<li>图像放大（例如，显示器适配）。</li>
<li>增强图像细节（例如，超分辨率重建）。</li>
</ul></li>
<li><p><strong>挑战</strong>：上采样可能引入模糊或伪影，需选择合适的插值或模型。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上采样（放大 2 倍）</span></span><br><span class="line">upsampled = cv2.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation=cv2.INTER_LINEAR)</span><br><span class="line"><span class="comment"># cv2.resize(src, dsize, fx, fy, interpolation): 调整图像大小。</span></span><br><span class="line"><span class="comment"># - src: 输入图像。</span></span><br><span class="line"><span class="comment"># - dsize: 输出图像尺寸（若为 None，则由 fx, fy 决定）。</span></span><br><span class="line"><span class="comment"># - fx, fy: x 和 y 方向的缩放因子（如 fx=2 表示宽度放大 2 倍）。</span></span><br><span class="line"><span class="comment"># - interpolation: 插值方法，如 cv2.INTER_LINEAR（双线性插值）。</span></span><br><span class="line"><span class="comment"># - 返回: 调整大小后的图像。</span></span><br></pre></td></tr></table></figure> ### 下采样</p></li>
<li><p><strong>定义</strong>：减少图像的分辨率（像素数量），通常用于图像缩小或减少计算量。</p></li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><strong>直接抽样</strong>：每隔固定间隔取一个像素（可能导致混叠）。</li>
<li><strong>平滑后抽样</strong>：先应用低通滤波（如高斯模糊）去除高频分量，再抽样以避免混叠。</li>
</ul></li>
<li><p><strong>应用</strong>：</p>
<ul>
<li>图像压缩（减少存储需求）。</li>
<li>构建图像金字塔（用于多尺度分析）。</li>
</ul></li>
<li><p><strong>挑战</strong>：下采样会丢失细节，需平衡分辨率与信息保留。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先高斯模糊以避免混叠</span></span><br><span class="line">blurred = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 下采样（缩小 0.5 倍）</span></span><br><span class="line">downsampled = cv2.resize(blurred, <span class="literal">None</span>, fx=<span class="number">0.5</span>, fy=<span class="number">0.5</span>, interpolation=cv2.INTER_LINEAR)</span><br><span class="line"><span class="comment"># cv2.GaussianBlur(src, ksize, sigmaX): 应用高斯模糊。</span></span><br><span class="line"><span class="comment"># - src: 输入图像。</span></span><br><span class="line"><span class="comment"># - ksize: 核大小，元组 (width, height)，必须为奇数（如 (5, 5)）。</span></span><br><span class="line"><span class="comment"># - sigmaX: x 方向高斯核标准差，0 表示自动计算。</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="卷积">卷积</h3>
<p>卷积是图像处理和机器学习中的核心操作，用于特征提取和滤波。</p>
<ul>
<li><strong>定义</strong>：通过一个小的滤波核（Kernel 或 Filter）在图像上滑动，计算核与图像区域的加权和，生成新的像素值。</li>
<li><strong>数学表示</strong>： 对于图像<span class="math inline">\(I(x, y)\)</span> 和核 <span class="math inline">\(K(m, n)\)</span>，卷积结果为： <span class="math inline">\(O(x, y) = \sum_{m} \sum_{n} I(x+m, y+n) \cdot K(m, n)\)</span> 其中 <span class="math inline">\(O(x, y)\)</span> 是输出图像的像素值。</li>
<li><strong>应用</strong>：
<ul>
<li>图像平滑（均值滤波、高斯滤波）。</li>
<li>边缘检测（Sobel、Prewitt 算子）。</li>
<li>特征提取（卷积神经网络 CNN 的核心操作）。</li>
</ul></li>
<li><strong>注意</strong>：
<ul>
<li>核大小通常为奇数（如 3x3、5x5），以确保中心像素对称。</li>
<li>边界处理：常用填充（Padding）方式，如零填充或镜像填充。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 3x3 锐化核</span></span><br><span class="line">kernel = np.array([[<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">				  [-<span class="number">1</span>, <span class="number">5</span>, -<span class="number">1</span>],</span><br><span class="line">				  [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]], dtype=np.float32)</span><br><span class="line"><span class="comment"># 应用卷积</span></span><br><span class="line">convolved = cv2.filter2D(img, -<span class="number">1</span>, kernel)</span><br><span class="line"><span class="comment"># cv2.filter2D(src, ddepth, kernel): 应用自定义卷积核。</span></span><br><span class="line"><span class="comment"># - src: 输入图像。</span></span><br><span class="line"><span class="comment"># - ddepth: 输出图像深度，-1 表示与输入相同。</span></span><br><span class="line"><span class="comment"># - kernel: 卷积核（NumPy 数组）。</span></span><br><span class="line"><span class="comment"># - 返回: 卷积后的图像。</span></span><br></pre></td></tr></table></figure>
<h3 id="直方图均衡化算法">直方图均衡化算法</h3>
<p>直方图均衡化是一种增强图像对比度的方法，通过重新分配像素强度值使直方图更均匀。</p>
<ul>
<li><strong>原理</strong>：
<ul>
<li>计算图像的灰度直方图。</li>
<li>计算累积分布函数（CDF，Cumulative Distribution Function）： <span class="math display">\[CDF(i) = \sum_{k=0}^{i} h(k)\]</span> 其中 <span class="math inline">\(h(k)\)</span> 是直方图值，<span class="math inline">\(i\)</span>是灰度级别。</li>
<li>归一化 CDF 并映射到目标范围（通常为 0 到 255）： <span class="math display">\[I_{\text{new}}(x, y) = \text{round}\left(\frac{CDF(I(x, y)) - CDF_{\text{min}}}{N - 1} \cdot (L-1)\right)\]</span>其中 <span class="math inline">\(N\)</span> 是像素总数，<span class="math inline">\(L\)</span>是量化级别数（如 256）。</li>
</ul></li>
<li><strong>步骤</strong>：
<ol type="1">
<li>计算直方图 <span class="math inline">\(h(i)\)</span>。</li>
<li>计算 CDF。</li>
<li>归一化并映射像素值。</li>
</ol></li>
<li><strong>效果</strong>：
<ul>
<li>增强图像对比度，尤其对低对比度图像效果显著。</li>
<li>可能放大噪声或导致不自然的对比度增强。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line">equalized = cv2.equalizeHist(img)</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="最近邻差值nearest-neighbor-interpolation">最近邻差值（Nearest Neighbor Interpolation）</h3>
<ul>
<li><strong>定义</strong>：一种简单的插值方法，用于上采样或下采样，选取距离目标点最近的像素值作为新像素值。</li>
<li><strong>特点</strong>：
<ul>
<li>计算简单，速度快。</li>
<li>结果可能出现块状伪影（“马赛克”效应），不平滑。</li>
</ul></li>
<li><strong>应用</strong>：适合对像素级精度要求高的场景（如像素艺术放大）。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最近邻插值（放大 2 倍）</span></span><br><span class="line">nearest = cv2.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation=cv2.INTER_NEAREST)</span><br></pre></td></tr></table></figure> ### 单/双线性差值（Bilinear Interpolation）</li>
<li><strong>单线性插值</strong>：
<ul>
<li>定义：在单一维度上使用线性插值，基于相邻两个点的距离加权平均。</li>
<li>公式：对于点 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(x_0\)</span> 和 <span class="math inline">\(x_1\)</span> 之间，值 <span class="math inline">\(f(x)\)</span> 为： <span class="math display">\[
f(x) = f(x_0) + \frac{x - x_0}{x_1 - x_0} \cdot (f(x_1) - f(x_0))
\]</span></li>
</ul></li>
<li><strong>双线性插值</strong>：
<ul>
<li>定义：在二维空间上扩展单线性插值，使用四个邻近像素的加权平均。</li>
<li>公式：对目标点 <span class="math inline">\((x, y)\)</span>，基于四个角点 <span class="math inline">\((x_0, y_0), (x_0, y_1), (x_1, y_0), (x_1, y_1)\)</span>，计算： <span class="math display">\[
f(x, y) = (1-w_x)(1-w_y)f(x_0, y_0) + w_x(1-w_y)f(x_1, y_0) + (1-w_x)w_y f(x_0, y_1) + w_x w_y f(x_1, y_1)
\]</span> 其中 <span class="math inline">\(w_x = \frac{x - x_0}{x_1 - x_0}\)</span>，<span class="math inline">\(w_y = \frac{y - y_0}{y_1 - y_0}\)</span>。</li>
</ul></li>
<li><strong>特点</strong>：
<ul>
<li>比最近邻插值更平滑，结果更自然。</li>
<li>计算复杂度适中，广泛用于图像缩放。</li>
</ul></li>
<li><strong>应用</strong>：
<ul>
<li>图像放大/缩小（如 OpenCV 的 <code>cv2.resize</code>）。</li>
<li>纹理映射（如 3D 渲染）。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 双线性插值（放大 2 倍）</span></span><br><span class="line">bilinear = cv2.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation=cv2.INTER_LINEAR)</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="特征选择与特征提取">特征选择与特征提取</h2>
<h3 id="特征选择与特征提取概述">特征选择与特征提取概述</h3>
<h4 id="特征选择-feature-selection">特征选择 (Feature Selection)</h4>
<ul>
<li><strong>定义</strong>: 从原始特征集合中选择一个子集，保留最相关、最具区分度的特征，去除冗余或无关特征。</li>
<li><strong>目标</strong>: 降低维度、减少计算量、避免过拟合、提高模型可解释性。</li>
<li><strong>方法分类</strong>:
<ul>
<li><strong>过滤法 (Filter Methods)</strong>: 基于统计指标（如方差、相关系数）选择特征，独立于模型。</li>
<li><strong>包装法 (Wrapper Methods)</strong>: 通过模型性能（如交叉验证）评估特征子集。</li>
<li><strong>嵌入法 (Embedded Methods)</strong>: 在模型训练过程中进行特征选择（如 LASSO 回归）。</li>
</ul></li>
<li><strong>优点</strong>: 保留原始特征的物理意义，计算效率较高。</li>
<li><strong>缺点</strong>: 可能忽略特征之间的复杂关系。</li>
</ul>
<h4 id="特征提取-feature-extraction">特征提取 (Feature Extraction)</h4>
<ul>
<li><strong>定义</strong>: 将原始高维数据通过变换（如线性或非线性映射）转换为新的低维特征空间，生成新的特征表示。</li>
<li><strong>目标</strong>: 提取更有代表性的特征，捕捉数据中的关键模式或结构。</li>
<li><strong>方法分类</strong>:
<ul>
<li><strong>线性方法</strong>: 如主成分分析 (PCA)、线性判别分析 (LDA)。</li>
<li><strong>非线性方法</strong>: 如 t-SNE、核 PCA、深度学习特征提取。</li>
</ul></li>
<li><strong>优点</strong>: 能捕捉复杂模式，适用于高维数据。</li>
<li><strong>缺点</strong>: 新特征可能丧失物理意义，计算复杂度较高。</li>
</ul>
<h4 id="差异">差异</h4>
<ul>
<li><strong>输入输出</strong>: 特征选择从原始特征中挑选子集，输出是原始特征的子集；特征提取生成新的特征表示。</li>
<li><strong>计算复杂度</strong>: 特征选择通常比特征提取简单。</li>
<li><strong>应用场景</strong>: 特征选择适合解释性要求高的场景；特征提取适合高维数据或需要捕捉复杂模式的场景。</li>
</ul>
<hr />
<h3 id="特征选择与特征提取原理">特征选择与特征提取原理</h3>
<h4 id="特征选择原理">特征选择原理</h4>
<p>特征选择的目的是从原始特征集合中挑选一个子集，保留最具区分度、最相关的特征，减少冗余和噪声。以下是其核心原理和数学基础：</p>
<ul>
<li><p><strong>目标</strong>: 最大化模型性能（如分类精度），最小化特征数量以降低计算复杂度和过拟合风险。</p></li>
<li><p><strong>数学表示</strong>: - 给定特征集 <span class="math inline">\(X = \{x_1, x_2, \dots, x_n\}\)</span>（每个 <span class="math inline">\(x_i\)</span> 是特征向量），目标是选择子集<span class="math inline">\(S\subseteq \{1, 2, \dots, n\}\)</span>，使得目标函数 <span class="math inline">\(J(S)\)</span>（如分类准确率）最大化： <span class="math display">\[
  S^* = \arg\max_{S} J(S), \quad \text{s.t.} \ |S| \leq k
  \]</span> 其中 <span class="math inline">\(k\)</span> 是期望的特征数量。</p></li>
<li><p><strong>方法分类</strong>: - <strong>过滤法 (Filter Methods)</strong>: 使用统计指标（如方差、相关系数、互信息）评估特征的重要性，独立于模型。例如，方差阈值方法移除方差低于某一值的特征： <span class="math display">\[
  \text{Var}(x_i) = \frac{1}{m} \sum_{j=1}^m (x_{i,j} - \mu_i)^2
  \]</span> 其中 <span class="math inline">\(\mu_i\)</span>是特征 <span class="math inline">\(x_i\)</span>的均值，<span class="math inline">\(m\)</span>是样本数。 - <strong>包装法 (Wrapper Methods)</strong>: 通过模型性能（如交叉验证得分）迭代评估特征子集。例如，递归特征消除 (RFE) 通过模型权重或重要性排序特征，逐步移除不重要特征。 - <strong>嵌入法 (Embedded Methods)</strong>: 在模型训练过程中进行特征选择。例如，L1 正则化 (LASSO) 通过惩罚项使不重要特征的权重趋于零： <span class="math display">\[
  \min_w \left( \frac{1}{m} \sum_{i=1}^m (y_i - w^T x_i)^2 + \lambda \|w\|_1 \right)
  \]</span> 其中 <span class="math inline">\(\lambda\)</span>控制正则化强度。</p></li>
</ul>
<h4 id="特征提取原理">特征提取原理</h4>
<p>特征提取通过变换将原始高维数据映射到低维空间，生成新的特征表示，捕捉数据的关键模式。</p>
<ul>
<li><strong>目标</strong>: 提取更具代表性的特征，降低维度，同时保留或增强数据区分能力。</li>
<li><strong>数学表示</strong>:
<ul>
<li>给定数据矩阵 <span class="math inline">\(X \in \mathbb{R}^{m \times n}\)</span>（<span class="math inline">\(m\)</span> 个样本，<span class="math inline">\(n\)</span> 个特征），特征提取寻找变换函数 <span class="math inline">\(f: \mathbb{R}^n \to \mathbb{R}^k\)</span>（<span class="math inline">\(k &lt; n\)</span>），使得新特征 <span class="math inline">\(Z = f(X)\)</span> 更适合后续任务。</li>
<li>线性方法（如 PCA）通过矩阵分解或投影实现： <span class="math display">\[
Z = X \cdot W
\]</span> 其中 <span class="math inline">\(W \in \mathbb{R}^{n \times k}\)</span> 是变换矩阵。</li>
<li>非线性方法（如 t-SNE）通过优化复杂目标函数（如 KL 散度）实现降维。</li>
</ul></li>
<li><strong>方法分类</strong>:
<ul>
<li><strong>线性方法</strong>: 主成分分析 (PCA)、线性判别分析 (LDA)。</li>
<li><strong>非线性方法</strong>: t-SNE、核 PCA、深度学习特征提取。</li>
<li><strong>局部特征提取</strong>: 如 SIFT、ORB、HOG，专注于图像局部不变特征。</li>
</ul></li>
</ul>
<hr />
<h3 id="扩展的特征选择方法及代码">扩展的特征选择方法及代码</h3>
<p>以下介绍三种特征选择方法：方差阈值（过滤法）、递归特征消除 (RFE, 包装法)、L1 正则化 (嵌入法)。</p>
<h4 id="方差阈值过滤法">方差阈值（过滤法）</h4>
<ul>
<li><strong>原理</strong>: 移除方差低于阈值的特征，因为低方差特征变化小，区分能力弱。</li>
<li><strong>数学</strong>: 计算每个特征的方差，选择方差大于阈值 <span class="math inline">\(\theta\)</span> 的特征： <span class="math display">\[
\text{Var}(x_i) \geq \theta
\]</span></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像并转换为灰度</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图像展平为一维特征向量（每像素作为一个特征）</span></span><br><span class="line">features = img.reshape(-<span class="number">1</span>, img.shape[<span class="number">0</span>] * img.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用方差阈值选择</span></span><br><span class="line">selector = VarianceThreshold(threshold=<span class="number">10.0</span>)</span><br><span class="line">selected_features = selector.fit_transform(features)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 代码将图像像素作为特征，使用 <code>VarianceThreshold</code> 移除方差低于 10 的特征。</p>
<hr />
<h4 id="递归特征消除-rfe-包装法">递归特征消除 (RFE, 包装法)</h4>
<ul>
<li><strong>原理</strong>: 使用模型（如 SVM）评估特征重要性，递归移除最不重要的特征，直到达到指定数量。</li>
<li><strong>数学</strong>: 对于模型权重 <span class="math inline">\(w\)</span>，特征重要性基于 <span class="math inline">\(|w_i|\)</span>，移除最小值后重新训练。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> RFE</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据：读取图像并提取简单特征</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">features = np.array([</span><br><span class="line">    [np.mean(img), np.std(img), np.<span class="built_in">max</span>(img)],  <span class="comment"># 特征：均值、标准差、最大值</span></span><br><span class="line">    [np.mean(img[::<span class="number">2</span>, ::<span class="number">2</span>]), np.std(img[::<span class="number">2</span>, ::<span class="number">2</span>]), np.<span class="built_in">max</span>(img[::<span class="number">2</span>, ::<span class="number">2</span>])], <span class="comment"># 隔1行下采样</span></span><br><span class="line">    [np.mean(img[::<span class="number">4</span>, ::<span class="number">4</span>]), np.std(img[::<span class="number">4</span>, ::<span class="number">4</span>]), np.<span class="built_in">max</span>(img[::<span class="number">4</span>, ::<span class="number">4</span>])], <span class="comment"># 隔3行下采样</span></span><br><span class="line">])</span><br><span class="line">labels = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])  <span class="comment"># 模拟标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 SVM 和 RFE 选择特征</span></span><br><span class="line">estimator = SVC(kernel=<span class="string">&quot;linear&quot;</span>)</span><br><span class="line">selector = RFE(estimator, n_features_to_select=<span class="number">2</span>)</span><br><span class="line">selector = selector.fit(features, labels)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 代码提取图像均值、标准差、最大值作为特征，使用 RFE 选择 2 个最重要特征。需更多样本和标签以实际应用。</p>
<hr />
<h4 id="l1-正则化嵌入法">L1 正则化（嵌入法）</h4>
<ul>
<li><strong>原理</strong>: 通过 L1 正则化（如 LASSO）使不重要特征的权重趋于零，自动选择特征。</li>
<li><strong>数学</strong>: 优化目标： <span class="math display">\[
\min_w \left( \frac{1}{m} \sum_{i=1}^m (y_i - w^T x_i)^2 + \lambda \|w\|_1 \right)
\]</span></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像并提取简单特征</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">features = np.array([</span><br><span class="line">    [np.mean(img), np.std(img), np.<span class="built_in">max</span>(img)],</span><br><span class="line">    [np.mean(img[::<span class="number">2</span>, ::<span class="number">2</span>]), np.std(img[::<span class="number">2</span>, ::<span class="number">2</span>]), np.<span class="built_in">max</span>(img[::<span class="number">2</span>, ::<span class="number">2</span>])],</span><br><span class="line">    [np.mean(img[::<span class="number">4</span>, ::<span class="number">4</span>]), np.std(img[::<span class="number">4</span>, ::<span class="number">4</span>]), np.<span class="built_in">max</span>(img[::<span class="number">4</span>, ::<span class="number">4</span>])],</span><br><span class="line">])</span><br><span class="line">labels = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])  <span class="comment"># 模拟标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 LASSO 进行特征选择</span></span><br><span class="line">lasso = Lasso(alpha=<span class="number">0.1</span>)  <span class="comment"># alpha 控制正则化强度</span></span><br><span class="line">lasso.fit(features, labels)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 代码使用 LASSO 回归选择特征，非零权重的特征被选中。</p>
<h3 id="扩展的特征提取方法及代码">扩展的特征提取方法及代码</h3>
<p>以下介绍五种特征提取方法：主成分分析 (PCA)、线性判别分析 (LDA)、SIFT、ORB 和 HOG。</p>
<h4 id="主成分分析-pca">主成分分析 (PCA)</h4>
<ul>
<li><strong>原理</strong>: 通过协方差矩阵的特征分解，将数据投影到方差最大的方向，降低维度，无监督。</li>
<li><strong>数学</strong>:
<ol type="1">
<li>标准化数据：<span class="math inline">\(X_{\text{norm}} = (X - \mu)/\sigma\)</span>。</li>
<li>计算协方差矩阵：<span class="math inline">\(C = \frac{1}{m} X_{\text{norm}}^T X_{\text{norm}}\)</span>。</li>
<li>特征分解：<span class="math inline">\(C = W \Lambda W^T\)</span>，选择前 <span class="math inline">\(k\)</span> 个特征向量 <span class="math inline">\(W_k\)</span>。</li>
<li>投影：<span class="math inline">\(Z = X_{\text{norm}} \cdot W_k\)</span>.</li>
</ol></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像并转换为灰度</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Image not found or invalid path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取 8x8 图像块作为样本</span></span><br><span class="line">patch_size = <span class="number">8</span></span><br><span class="line">patches = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.shape[<span class="number">0</span>] - patch_size + <span class="number">1</span>, patch_size):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.shape[<span class="number">1</span>] - patch_size + <span class="number">1</span>, patch_size):</span><br><span class="line">        patch = img[i:i+patch_size, j:j+patch_size].flatten()</span><br><span class="line">        patches.append(patch)</span><br><span class="line">features = np.array(patches)  <span class="comment"># 形状: (n_patches, patch_size * patch_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态选择 n_components</span></span><br><span class="line">n_components = <span class="built_in">min</span>(<span class="number">3</span>, <span class="built_in">min</span>(features.shape))  <span class="comment"># 最多 3 维</span></span><br><span class="line">pca = PCA(n_components=n_components)</span><br><span class="line">reduced_features = pca.fit_transform(features)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重构图像（仅用于展示）</span></span><br><span class="line">reconstructed = pca.inverse_transform(reduced_features)</span><br><span class="line">reconstructed_patches = reconstructed.reshape(-<span class="number">1</span>, patch_size, patch_size)</span><br><span class="line"><span class="comment"># 将 patches 重新拼接为图像（近似）</span></span><br><span class="line">h, w = img.shape</span><br><span class="line">n_patches_h = (h - patch_size + <span class="number">1</span>) // patch_size</span><br><span class="line">n_patches_w = (w - patch_size + <span class="number">1</span>) // patch_size</span><br><span class="line">reconstructed_img = np.zeros((h, w))</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_patches_h):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n_patches_w):</span><br><span class="line">        reconstructed_img[i*patch_size:(i+<span class="number">1</span>)*patch_size, j*patch_size:(j+<span class="number">1</span>)*patch_size] = reconstructed_patches[count]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;pca_reconstructed.jpg&#x27;</span>, reconstructed_img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(reconstructed_img, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">f&#x27;PCA Reconstructed (n_components=<span class="subst">&#123;n_components&#125;</span>)&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印方差解释率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Features shape:&quot;</span>, features.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Explained variance ratio:&quot;</span>, pca.explained_variance_ratio_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cumulative variance ratio:&quot;</span>, pca.explained_variance_ratio_.cumsum())</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 代码将图像像素降维到 2 维并重构，展示 PCA 效果。</p>
<hr />
<h4 id="线性判别分析-lda">线性判别分析 (LDA)</h4>
<ul>
<li><strong>原理</strong>: 最大化类间方差、最小化类内方差，适用于监督学习，一般需要多张图片，因为单一张图片标签难以提取。</li>
<li><strong>数学</strong>:
<ol type="1">
<li>计算类内散布矩阵 <span class="math inline">\(S_W\)</span> 和类间散布矩阵 <span class="math inline">\(S_B\)</span>： <span class="math display">\[
S_W = \sum_{c} \sum_{i \in c} (x_i - \mu_c)(x_i - \mu_c)^T, \quad S_B = \sum_{c} n_c (\mu_c - \mu)(\mu_c - \mu)^T
\]</span></li>
<li>求解广义特征值问题：<span class="math inline">\(S_W^{-1} S_B w = \lambda w\)</span>，取前 <span class="math inline">\(k\)</span> 个特征向量。</li>
</ol></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取两张图像并转换为灰度</span></span><br><span class="line">img1 = cv2.imread(<span class="string">&#x27;image1.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;image2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="keyword">if</span> img1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> img2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;Image not found or invalid path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取 8x8 图像块作为样本</span></span><br><span class="line">patch_size = <span class="number">8</span></span><br><span class="line">patches = []</span><br><span class="line">labels = [] <span class="comment"># 监督类别</span></span><br><span class="line"><span class="keyword">for</span> img, label <span class="keyword">in</span> [(img1, <span class="number">0</span>), (img2, <span class="number">1</span>)]:  <span class="comment"># 图像1: 类别0, 图像2: 类别1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.shape[<span class="number">0</span>] - patch_size + <span class="number">1</span>, patch_size):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, img.shape[<span class="number">1</span>] - patch_size + <span class="number">1</span>, patch_size):</span><br><span class="line">            patch = img[i:i+patch_size, j:j+patch_size].flatten()</span><br><span class="line">            patches.append(patch)</span><br><span class="line">            labels.append(label)</span><br><span class="line">features = np.array(patches)  <span class="comment"># 形状: (n_patches, 64)</span></span><br><span class="line">labels = np.array(labels)  <span class="comment"># 形状: (n_patches,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态选择 n_components（LDA 最多 C-1 维，C 为类别数）</span></span><br><span class="line">n_classes = <span class="built_in">len</span>(np.unique(labels))  <span class="comment"># 类别数</span></span><br><span class="line">n_components = <span class="built_in">min</span>(<span class="number">1</span>, n_classes - <span class="number">1</span>, <span class="built_in">min</span>(features.shape))  <span class="comment"># 2 类时最多 1 维</span></span><br><span class="line">lda = LinearDiscriminantAnalysis(n_components=n_components)</span><br><span class="line">reduced_features = lda.fit_transform(features, labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Features shape:&quot;</span>, features.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Reduced features shape:&quot;</span>, reduced_features.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Explained variance ratio:&quot;</span>, lda.explained_variance_ratio_)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 代码模拟两张图像（需 <code>image1.jpg</code> 和 <code>image2.jpg</code>），使用 LDA 降维到 1 维。实际应用需更多样本。</p>
<h4 id="sift-特征提取">SIFT 特征提取</h4>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>目标</strong>：检测图像中的关键点（角点等），并为每个关键点生成描述子，用于图像匹配、目标识别等任务。</li>
<li><strong>特性</strong>：
<ul>
<li><strong>尺度不变</strong>：通过尺度空间检测，适应不同大小的目标。</li>
<li><strong>旋转不变</strong>：通过分配主方向，描述子相对于方向归一化。</li>
<li><strong>光照鲁棒</strong>：基于梯度信息，对亮度变化不敏感。</li>
</ul></li>
<li><strong>应用</strong>：图像匹配、物体识别、3D重建。</li>
</ul>
<h4 id="sift算法步骤">SIFT算法步骤</h4>
<ol type="1">
<li><strong>尺度空间极值检测</strong>：
<ul>
<li>构建高斯金字塔（不同尺度和模糊程度的图像）。</li>
<li>计算相邻尺度的高斯差分（DoG，Difference of Gaussian）： <span class="math display">\[D(x, y, \sigma) = L(x, y, k\sigma) - L(x, y, \sigma) \]</span>其中<span class="math inline">\(L(x, y, \sigma) = G(x, y, \sigma) * I(x, y)\)</span>是高斯模糊图像。其实本质是求二次偏导，其函数形式与DoG十分类似，故使用DoG函数。</li>
<li>在DoG中寻找局部极值点（3D空间：x, y, 尺度）。</li>
</ul></li>
<li><strong>关键点定位</strong>：
<ul>
<li>过滤低对比度或边缘点，确保关键点稳定。</li>
<li>使用泰勒展开精确定位极值点。</li>
</ul></li>
<li><strong>方向分配</strong>：
<ul>
<li>计算关键点邻域的梯度方向直方图，分配主方向（峰值方向）。</li>
<li>使描述子对旋转不变。</li>
</ul></li>
<li><strong>描述子生成</strong>：
<ul>
<li>在关键点周围取16x16邻域，分成4x4子块。</li>
<li>每个子块计算8个方向的梯度直方图，生成128维描述子（4x4x8=128）。</li>
</ul></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像并转换为灰度</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 SIFT 检测器</span></span><br><span class="line">sift = cv2.SIFT_create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测关键点和计算描述子</span></span><br><span class="line">keypoints, descriptors = sift.detectAndCompute(img, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制关键点</span></span><br><span class="line">img_with_keypoints = cv2.drawKeypoints(img, keypoints, <span class="literal">None</span>, flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;sift_keypoints.jpg&#x27;</span>, img_with_keypoints)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.imshow(img_with_keypoints, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;SIFT Keypoints&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印关键点数量和描述子形状</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Number of keypoints: <span class="subst">&#123;<span class="built_in">len</span>(keypoints)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Descriptor shape: <span class="subst">&#123;descriptors.shape&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># cv2.SIFT_create(): 创建 SIFT 检测器。</span></span><br><span class="line"><span class="comment">#   - 返回: SIFT 对象。</span></span><br><span class="line"><span class="comment"># cv2.SIFT.detectAndCompute(image, mask): 检测关键点并计算描述子。</span></span><br><span class="line"><span class="comment">#   - image: 输入灰度图像。</span></span><br><span class="line"><span class="comment">#   - mask: 可选掩码，None 表示使用整个图像。</span></span><br><span class="line"><span class="comment">#   - 返回: 关键点列表 (keypoints) 和描述子数组 (descriptors)。</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 代码提取 SIFT 关键点和描述子，需 <code>opencv-contrib-python</code>。</p>
<hr />
<h4 id="orb-特征提取">ORB 特征提取</h4>
<ul>
<li><strong>原理</strong>: 方向快速和旋转 BRIEF (ORB) 是一种高效的局部特征检测算法，结合 FAST 关键点检测和 BRIEF 描述子，速度快且对旋转鲁棒。但是对尺度的检测并不十分敏感。算法主要是求速度。</li>
<li><strong>步骤</strong>:
<ol type="1">
<li>FAST 检测关键点。</li>
<li>计算关键点方向。</li>
<li>生成 BRIEF 描述子。</li>
</ol></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像并转换为灰度</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 ORB 检测器</span></span><br><span class="line">orb = cv2.ORB_create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测关键点和计算描述子</span></span><br><span class="line">keypoints, descriptors = orb.detectAndCompute(img, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制关键点</span></span><br><span class="line">img_with_keypoints = cv2.drawKeypoints(img, keypoints, <span class="literal">None</span>, flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存结果</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;orb_keypoints.jpg&#x27;</span>, img_with_keypoints)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.imshow(img_with_keypoints, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;ORB Keypoints&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印关键点数量和描述子形状</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Number of keypoints: <span class="subst">&#123;<span class="built_in">len</span>(keypoints)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Descriptor shape: <span class="subst">&#123;descriptors.shape&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 代码使用 ORB 检测关键点，速度比 SIFT 快，适合实时应用。</p>
<hr />
<h4 id="hog-特征提取">HOG 特征提取</h4>
<ul>
<li><strong>原理</strong>: 方向梯度直方图 (HOG) 通过计算图像局部区域的梯度方向直方图，生成特征描述子，常用于行人检测。</li>
<li><strong>步骤</strong>:
<ol type="1">
<li>计算图像梯度（x 和 y 方向）。</li>
<li>将图像分成小单元 (cell，一般8×8)，计算每个单元的梯度方向直方图。</li>
<li>将单元组成块 (block，一般2×2cell)，归一化直方图。</li>
<li>连接所有块的特征向量。</li>
</ol></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像并转换为灰度</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整图像大小以适合 HOG</span></span><br><span class="line">img = cv2.resize(img, (<span class="number">128</span>, <span class="number">64</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 HOG 特征</span></span><br><span class="line">hog_features, hog_image = hog(img, pixels_per_cell=(<span class="number">8</span>, <span class="number">8</span>), cells_per_block=(<span class="number">2</span>, <span class="number">2</span>), visualize=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存 HOG 可视化图像</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;hog_image.jpg&#x27;</span>, hog_image * <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(hog_image, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;HOG Visualization&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 HOG 特征长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;HOG feature length: <span class="subst">&#123;<span class="built_in">len</span>(hog_features)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 代码使用 <code>skimage.feature.hog</code> 计算 HOG 特征，需安装 <code>scikit-image</code> (<code>pip install scikit-image</code>)。</p>
<hr />
<h3 id="总结">总结</h3>
<ul>
<li><strong>特征选择</strong>:
<ul>
<li><strong>方差阈值</strong>: 简单高效，适合高维数据筛选。</li>
<li><strong>RFE</strong>: 结合模型性能，精准但计算成本高。</li>
<li><strong>L1 正则化</strong>: 自动选择特征，适合回归任务。</li>
</ul></li>
<li><strong>特征提取</strong>:
<ul>
<li><strong>PCA</strong>: 线性降维，适合图像压缩。</li>
<li><strong>LDA</strong>: 监督降维，适合分类任务。</li>
<li><strong>SIFT</strong>: 尺度不变特征，适合图像匹配。</li>
<li><strong>ORB</strong>: 高效局部特征，适合实时应用。</li>
<li><strong>HOG</strong>: 梯度方向特征，适合行人检测。</li>
<li>除此之外还有SURF(基于SIFT的快速算法)、LBP(人脸识别)等 [[../TrDentityCo.png]]</li>
</ul></li>
<li><strong>OpenCV 应用</strong>:
<ul>
<li>特征选择常结合 <code>sklearn</code>，特征提取可直接使用 OpenCV 的 SIFT、ORB 或外部库的 HOG。</li>
<li>这些方法在图像分类、目标检测、图像检索中广泛应用。</li>
</ul></li>
</ul>
<h2 id="边缘提取">边缘提取</h2>
<p>边缘提取是计算机视觉的基础任务，用于检测图像中亮度或颜色发生显著变化的区域，通常对应于物体的边界。本文记录以下常用方法<strong>Canny</strong>、<strong>Roberts</strong>、<strong>Sobel</strong>、<strong>Prewitt</strong>、<strong>Hessian特征</strong>、<strong>Haar特征</strong>、<strong>Laplacian</strong>和<strong>Scharr</strong>。</p>
<h3 id="canny-边缘检测">1. Canny 边缘检测</h3>
<h4 id="原理">原理</h4>
<p>Canny 边缘检测是一种多阶段算法，旨在检测强边缘并抑制噪声。它包括以下步骤： 1. <strong>噪声抑制</strong>：使用高斯模糊平滑图像，减少噪声影响。 2. <strong>梯度计算</strong>：使用 Sobel 算子计算图像的强度梯度和方向。 3. <strong>非极大值抑制</strong>：在梯度方向上，仅保留局部最大值，抑制非边缘点。 4. <strong>双阈值检测</strong>：使用高低阈值将边缘分为强边缘、弱边缘和非边缘。 5. <strong>边缘跟踪</strong>：通过连通性分析，将弱边缘与强边缘连接，剔除孤立点。</p>
<h4 id="优缺点">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>检测精度高，边缘定位准确。</li>
<li>能有效抑制噪声，减少误检。</li>
<li>提供连通性强的边缘。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>计算复杂度较高，实时性较差。</li>
<li>对阈值选择敏感，需手动调整。</li>
<li>对复杂背景的边缘检测可能不理想。</li>
</ul></li>
</ul>
<h4 id="适用条件">适用条件</h4>
<ul>
<li>适用于需要高质量边缘检测的场景，如图像分割、物体检测。</li>
<li>适合噪声较少的图像，或经过预处理的图像。</li>
</ul>
<h4 id="python-opencv-代码">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Canny 边缘检测</span></span><br><span class="line">edges = cv2.Canny(img, threshold1=<span class="number">100</span>, threshold2=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<h3 id="roberts-边缘检测">2. Roberts 边缘检测</h3>
<h4 id="原理-1">原理</h4>
<p>Roberts 算子是一种简单的边缘检测方法，使用 2x2 的卷积核计算图像的梯度。它通过以下两个核检测对角方向的边缘： - <span class="math inline">\(G_x = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{bmatrix}\)</span> - <span class="math inline">\(G_y = \begin{bmatrix} 0 &amp; 1 \\ -1 &amp; 0 \end{bmatrix}\)</span></p>
<p>梯度幅值计算为：<span class="math inline">\(G = \sqrt{G_x^2 + G_y^2}\)</span>。</p>
<h4 id="优缺点-1">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>计算简单，速度快。</li>
<li>对对角边缘敏感。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>对噪声非常敏感，容易产生伪边缘。</li>
<li>仅检测对角方向边缘，对水平和垂直边缘效果较差。</li>
<li>边缘定位不精确。</li>
</ul></li>
</ul>
<h4 id="适用条件-1">适用条件</h4>
<ul>
<li>适用于噪声极低的简单图像。</li>
<li>适合对计算速度要求高的实时应用。</li>
</ul>
<h4 id="python-opencv-代码-1">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 Roberts 算子</span></span><br><span class="line">roberts_x = np.array([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]], dtype=np.float32)</span><br><span class="line">roberts_y = np.array([[<span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卷积操作</span></span><br><span class="line">edge_x = cv2.filter2D(img, -<span class="number">1</span>, roberts_x)</span><br><span class="line">edge_y = cv2.filter2D(img, -<span class="number">1</span>, roberts_y)</span><br><span class="line">edges = np.sqrt(np.square(edge_x) + np.square(edge_y)).astype(np.uint8)</span><br></pre></td></tr></table></figure>
<h3 id="sobel-边缘检测">3. Sobel 边缘检测</h3>
<h4 id="原理-2">原理</h4>
<p>Sobel 算子通过 3x3 的卷积核计算图像在水平和垂直方向的梯度，强调边缘区域。它使用以下核： - <span class="math inline">\(G_x = \begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -2 &amp; 0 &amp; 2 \\ -1 &amp; 0 &amp; 1 \end{bmatrix}\)</span> - <span class="math inline">\(G_y = \begin{bmatrix} -1 &amp; -2 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 2 &amp; 1 \end{bmatrix}\)</span></p>
<p>梯度幅值为：<span class="math inline">\(G = \sqrt{G_x^2 + G_y^2}\)</span>，方向为：<span class="math inline">\(\theta = \arctan(G_y / G_x)\)</span>。</p>
<h4 id="优缺点-2">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>对水平和垂直边缘检测效果较好。</li>
<li>计算简单，适合实时处理。</li>
<li>比 Roberts 更抗噪。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>对对角边缘检测较弱。</li>
<li>边缘可能较粗糙，定位不够精确。</li>
<li>对高噪声图像效果较差。</li>
</ul></li>
</ul>
<h4 id="适用条件-2">适用条件</h4>
<ul>
<li>适用于检测水平和垂直边缘的场景，如道路线检测。</li>
<li>适合噪声适中的图像。</li>
</ul>
<h4 id="python-opencv-代码-2">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sobel 边缘检测</span></span><br><span class="line">sobel_x = cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobel_y = cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">edges = np.sqrt(np.square(sobel_x) + np.square(sobel_y)).astype(np.uint8)  <span class="comment"># uint8是灰度格式，这里是转化成灰度图</span></span><br></pre></td></tr></table></figure>
<h3 id="prewitt-边缘检测">4. Prewitt 边缘检测</h3>
<h4 id="原理-3">原理</h4>
<p>Prewitt 算子与 Sobel 类似，也是 3x3 卷积核，用于计算水平和垂直方向的梯度，但权重更均匀： - <span class="math inline">\(G_x = \begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \\ -1 &amp; 0 &amp; 1 \end{bmatrix}\)</span> - <span class="math inline">\(G_y = \begin{bmatrix} -1 &amp; -1 &amp; -1 \\ 0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}\)</span></p>
<p>梯度幅值和方向计算同 Sobel。</p>
<h4 id="优缺点-3">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>计算简单，速度快。</li>
<li>对水平和垂直边缘有较好响应。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>比 Sobel 更易受噪声影响。</li>
<li>边缘定位精度较低。</li>
<li>对复杂纹理图像效果较差。</li>
</ul></li>
</ul>
<h4 id="适用条件-3">适用条件</h4>
<ul>
<li>适用于简单图像的边缘检测。</li>
<li>适合对噪声要求不高的场景。</li>
</ul>
<h4 id="python-opencv-代码-3">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 Prewitt 算子</span></span><br><span class="line">prewitt_x = np.array([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]], dtype=np.float32)</span><br><span class="line">prewitt_y = np.array([[-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卷积操作</span></span><br><span class="line">edge_x = cv2.filter2D(img, -<span class="number">1</span>, prewitt_x)</span><br><span class="line">edge_y = cv2.filter2D(img, -<span class="number">1</span>, prewitt_y)</span><br><span class="line">edges = np.sqrt(np.square(edge_x) + np.square(edge_y)).astype(np.uint8)</span><br></pre></td></tr></table></figure>
<h3 id="hessian-特征">5. Hessian 特征</h3>
<h4 id="原理-4">原理</h4>
<p>Hessian 特征基于图像的二阶导数，通过 Hessian 矩阵检测图像中的显著点（如角点或边缘）。Hessian 矩阵定义为： <span class="math display">\[ H = \begin{bmatrix} I_{xx} &amp; I_{xy} \\ I_{xy} &amp; I_{yy} \end{bmatrix} \]</span> 其中 <span class="math inline">\(I_{xx}, I_{xy}, I_{yy}\)</span> 是图像的二阶偏导数。特征点通过矩阵的行列式或特征值分析确定。</p>
<p>在边缘检测中，Hessian 常用于检测细长结构（如血管），通过分析行列式 <span class="math inline">\(\det(H)\)</span> 或特征值。</p>
<h4 id="优缺点-4">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>对细长边缘或线状结构检测效果好。</li>
<li>能捕捉图像的局部几何特征。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>计算复杂度高，需计算二阶导数。</li>
<li>对噪声敏感，需预处理。</li>
<li>不适合检测宽边缘或复杂纹理。</li>
</ul></li>
</ul>
<h4 id="适用条件-4">适用条件</h4>
<ul>
<li>适用于医疗图像（如血管分割）或线状结构检测。</li>
<li>适合噪声较低或经过平滑处理的图像。</li>
</ul>
<h4 id="python-opencv-代码-4">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> gaussian_laplace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE).astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 Hessian 矩阵的行列式（近似）</span></span><br><span class="line">sigma = <span class="number">2.0</span></span><br><span class="line">img_xx = cv2.Sobel(cv2.Sobel(img, cv2.CV_64F, <span class="number">2</span>, <span class="number">0</span>, ksize=<span class="number">3</span>), cv2.CV_64F, <span class="number">2</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)</span><br><span class="line">img_yy = cv2.Sobel(cv2.Sobel(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">2</span>, ksize=<span class="number">3</span>), cv2.CV_64F, <span class="number">0</span>, <span class="number">2</span>, ksize=<span class="number">3</span>)</span><br><span class="line">img_xy = cv2.Sobel(cv2.Sobel(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>), cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">det_H = img_xx * img_yy - img_xy ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化显示</span></span><br><span class="line">det_H = cv2.normalize(det_H, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Original Image&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(det_H, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Hessian Determinant&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="haar-特征">6. Haar 特征</h3>
<h4 id="原理-5">原理</h4>
<p>Haar 特征主要用于目标检测（如人脸检测），通过计算矩形区域的像素强度差值提取特征。Haar 特征包括： - 边缘特征：检测水平或垂直边缘。 - 线特征：检测线状结构。 - 中心-环绕特征：检测中心与周围的差异。</p>
<p>特征值计算为：白色区域像素和减去黑色区域像素和。Haar 特征通常结合积分图像加速计算。</p>
<h4 id="优缺点-5">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>计算速度快，适合实时应用。</li>
<li>对简单边缘和纹理特征有效。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>对复杂边缘或非矩形特征检测效果差。</li>
<li>对光照变化和旋转敏感。</li>
<li>需大量训练数据（如用于人脸检测）。</li>
</ul></li>
</ul>
<h4 id="适用条件-5">适用条件</h4>
<ul>
<li>适用于目标检测（如人脸、车辆）。</li>
<li>适合光照均匀、目标形状规则的场景。</li>
</ul>
<h4 id="python-opencv-代码-5">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义简单的 Haar 特征（水平边缘）</span></span><br><span class="line">haar_kernel = np.array([[<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]], dtype=np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卷积操作</span></span><br><span class="line">haar_edges = cv2.filter2D(img, -<span class="number">1</span>, haar_kernel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化显示</span></span><br><span class="line">haar_edges = cv2.normalize(haar_edges, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Original Image&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(haar_edges, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Haar Edges&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="laplacian-边缘检测">7. Laplacian 边缘检测</h3>
<h4 id="原理-6">原理</h4>
<p>Laplacian 算子基于图像的二阶导数，检测亮度变化的区域。它使用以下核： <span class="math display">\[ \nabla^2 I = \begin{bmatrix} 0 &amp; 1 &amp; 0 \\ 1 &amp; -4 &amp; 1 \\ 0 &amp; 1 &amp; 0 \end{bmatrix} \]</span></p>
<p>Laplacian 检测零交叉点作为边缘。</p>
<h4 id="优缺点-6">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>对所有方向的边缘敏感。</li>
<li>计算简单。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>极易受噪声影响，需预平滑。</li>
<li>边缘可能不连续，需后处理。</li>
</ul></li>
</ul>
<h4 id="适用条件-6">适用条件</h4>
<ul>
<li>适用于噪声低的图像。</li>
<li>适合与高斯平滑结合使用。</li>
</ul>
<h4 id="python-opencv-代码-6">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯平滑</span></span><br><span class="line">img_blur = cv2.GaussianBlur(img, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Laplacian 边缘检测</span></span><br><span class="line">edges = cv2.Laplacian(img_blur, cv2.CV_64F)</span><br><span class="line">edges = cv2.normalize(edges, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Original Image&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(edges, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Laplacian Edges&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="scharr-边缘检测">8. Scharr 边缘检测</h3>
<h4 id="原理-7">原理</h4>
<p>Scharr 算子是 Sobel 的改进版，使用更精确的权重来计算梯度： - <span class="math inline">\(G_x = \begin{bmatrix} -3 &amp; 0 &amp; 3 \\ -10 &amp; 0 &amp; 10 \\ -3 &amp; 0 &amp; 3 \end{bmatrix}\)</span> - <span class="math inline">\(G_y = \begin{bmatrix} -3 &amp; -10 &amp; -3 \\ 0 &amp; 0 &amp; 0 \\ 3 &amp; 10 &amp; 3 \end{bmatrix}\)</span></p>
<h4 id="优缺点-7">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>比 Sobel 更精确，边缘定位更好。</li>
<li>计算速度与 Sobel 相近。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>对噪声仍较敏感。</li>
<li>对复杂纹理效果有限。</li>
</ul></li>
</ul>
<h4 id="适用条件-7">适用条件</h4>
<ul>
<li>适用于需要高精度边缘检测的场景。</li>
<li>适合噪声适中的图像。</li>
</ul>
<h4 id="python-opencv-代码-7">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Scharr 边缘检测</span></span><br><span class="line">scharr_x = cv2.Scharr(img, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">scharr_y = cv2.Scharr(img, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">edges = np.sqrt(np.square(scharr_x) + np.square(scharr_y)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Original Image&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(edges, cmap=<span class="string">&#x27;gray&#x27;</span>), plt.title(<span class="string">&#x27;Scharr Edges&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="相机模型">相机模型</h2>
<p>相机模型描述了三维世界如何通过相机投影到二维图像平面。以下是对你列出的内容（小孔成像模型、相机模型、镜头畸变、透视变换）以及补充内容（鱼眼模型、立体视觉）的详细讲解。</p>
<h3 id="小孔成像模型">1. 小孔成像模型</h3>
<h4 id="原理-8">原理</h4>
<p>小孔成像模型是相机成像的理想化模型，假设光线通过一个无穷小的孔（针孔）投影到成像平面，无透镜畸变。数学表达为： <span class="math display">\[ \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \frac{f}{Z} \begin{bmatrix} X \\ Y \\ Z \end{bmatrix} \]</span> 其中： - <span class="math inline">\((X, Y, Z)\)</span>：世界坐标。 - <span class="math inline">\((u, v)\)</span>：图像坐标。 - <span class="math inline">\(f\)</span>：焦距。 - <span class="math inline">\(Z\)</span>：物体到针孔的深度。</p>
<h4 id="优缺点-8">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>模型简单，易于理解和计算。</li>
<li>无畸变，适合理论分析。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>针孔会导致光量不足，实际相机需透镜。</li>
<li>不考虑畸变，无法描述真实相机。</li>
</ul></li>
</ul>
<h4 id="适用条件-8">适用条件</h4>
<ul>
<li>适用于教学和简单几何分析。</li>
<li>不适合需要高精度建模的实际应用。</li>
</ul>
<h4 id="python-opencv-代码-8">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟小孔成像</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pinhole_projection</span>(<span class="params">points_3d, focal_length</span>):</span><br><span class="line">    points_2d = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points_3d:</span><br><span class="line">        X, Y, Z = point</span><br><span class="line">        u = (focal_length * X) / Z</span><br><span class="line">        v = (focal_length * Y) / Z</span><br><span class="line">        points_2d.append([u, v])</span><br><span class="line">    <span class="keyword">return</span> np.array(points_2d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 3D 点</span></span><br><span class="line">points_3d = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]])</span><br><span class="line">focal_length = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 投影到 2D</span></span><br><span class="line">points_2d = pinhole_projection(points_3d, focal_length)</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="相机模型针孔相机模型内参外参">2. 相机模型（针孔相机模型+内参外参）</h3>
<h4 id="原理-9">原理</h4>
<p>相机模型是对小孔成像的扩展，考虑内参（焦距、 principal point）和外参（旋转、平移）。投影公式为： <span class="math display">\[ \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = K [R | t] \begin{bmatrix} X \\ Y \\ Z \\ 1 \end{bmatrix} \]</span> 其中： - <span class="math inline">\(K = \begin{bmatrix} f_x &amp; 0 &amp; c_x \\ 0 &amp; f_y &amp; c_y \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span>：内参矩阵，<span class="math inline">\(f_x, f_y\)</span> 为焦距，<span class="math inline">\(c_x, c_y\)</span> 为 principal point。 - <span class="math inline">\([R | t]\)</span>：外参矩阵，<span class="math inline">\(R\)</span> 为旋转矩阵，<span class="math inline">\(t\)</span> 为平移向量。</p>
<h4 id="优缺点-9">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>能精确描述相机成像过程。</li>
<li>支持 3D 重建和姿态估计。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>不考虑镜头畸变，需额外校正。</li>
<li>标定过程复杂。</li>
</ul></li>
</ul>
<h4 id="适用条件-9">适用条件</h4>
<ul>
<li>适用于 3D 重建、SLAM、增强现实。</li>
<li>适合需要精确几何关系的场景。</li>
</ul>
<h4 id="python-opencv-代码-9">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义内参矩阵</span></span><br><span class="line">focal_length = <span class="number">500</span></span><br><span class="line">cx, cy = <span class="number">320</span>, <span class="number">240</span></span><br><span class="line">K = np.array([[focal_length, <span class="number">0</span>, cx], [<span class="number">0</span>, focal_length, cy], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义外参（旋转矩阵和平移向量）</span></span><br><span class="line">R = np.eye(<span class="number">3</span>)</span><br><span class="line">t = np.array([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 3D 点</span></span><br><span class="line">points_3d = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>]], dtype=np.float32).T</span><br><span class="line">points_3d_h = np.vstack((points_3d, np.ones((<span class="number">1</span>, points_3d.shape[<span class="number">1</span>]))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 投影到 2D</span></span><br><span class="line">Rt = np.hstack((R, t))</span><br><span class="line">points_2d_h = K @ Rt @ points_3d_h</span><br><span class="line">points_2d = (points_2d_h[:<span class="number">2</span>] / points_2d_h[<span class="number">2</span>]).T</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="镜头畸变">3. 镜头畸变</h3>
<h4 id="原理-10">原理</h4>
<p>镜头畸变是由于透镜非理想性导致的图像失真，主要包括： - <strong>径向畸变</strong>：靠近图像中心的点移向边缘（桶形畸变）或反之（枕形畸变）。模型为： <span class="math display">\[ x_d = x (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \]</span> <span class="math display">\[ y_d = y (1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \]</span> 其中 <span class="math inline">\(r = \sqrt{x^2 + y^2}\)</span>，<span class="math inline">\(k_1, k_2, k_3\)</span> 为径向畸变系数。 - <strong>切向畸变</strong>：由于透镜与传感器不完全平行，模型为： <span class="math display">\[ x_d = x + [2 p_1 x y + p_2 (r^2 + 2 x^2)] \]</span> <span class="math display">\[ y_d = y + [p_1 (r^2 + 2 y^2) + 2 p_2 x y] \]</span></p>
<h4 id="优缺点-10">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>校正畸变后可获得更精确的几何关系。</li>
<li>适用于广角镜头或鱼眼镜头。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>标定过程复杂，需棋盘格或其他标定物。</li>
<li>校正可能导致图像部分区域丢失。</li>
</ul></li>
</ul>
<h4 id="适用条件-10">适用条件</h4>
<ul>
<li>适用于广角镜头或高精度成像系统。</li>
<li>适合需要校正畸变的场景，如 3D 重建、SLAM。</li>
</ul>
<h4 id="python-opencv-代码-10">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义内参和畸变系数（需通过标定获得）</span></span><br><span class="line">K = np.array([[<span class="number">500</span>, <span class="number">0</span>, <span class="number">320</span>], [<span class="number">0</span>, <span class="number">500</span>, <span class="number">240</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">dist_coeffs = np.array([<span class="number">0.1</span>, -<span class="number">0.01</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])  <span class="comment"># k1, k2, p1, p2, k3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 校正畸变</span></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">new_K, roi = cv2.getOptimalNewCameraMatrix(K, dist_coeffs, (w, h), <span class="number">1</span>, (w, h))</span><br><span class="line">undistorted_img = cv2.undistort(img, K, dist_coeffs, <span class="literal">None</span>, new_K)</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="透视变换">4. 透视变换</h3>
<h4 id="原理-11">原理</h4>
<p>透视变换将图像从一个视角变换到另一个视角，基于单应性矩阵（Homography）。变换公式为： <span class="math display">\[ \begin{bmatrix} u&#39; \\ v&#39; \\ 1 \end{bmatrix} = H \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} \]</span> 其中 <span class="math inline">\(H\)</span> 是一个 3x3 矩阵，通过至少 4 对对应点计算。</p>
<h4 id="优缺点-11">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>能实现图像的视角变换，适用于校正倾斜或拼接。</li>
<li>计算简单，效果直观。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>要求平面场景，非平面场景会失效。</li>
<li>对对应点精度要求高。</li>
</ul></li>
</ul>
<h4 id="适用条件-11">适用条件</h4>
<ul>
<li>适用于图像拼接、文档校正、增强现实。</li>
<li>适合平面对象的视角变换。</li>
</ul>
<h4 id="python-opencv-代码-11">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;image.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义原始点和目标点</span></span><br><span class="line">src_points = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [img.shape[<span class="number">1</span>]-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, img.shape[<span class="number">0</span>]-<span class="number">1</span>], [img.shape[<span class="number">1</span>]-<span class="number">1</span>, img.shape[<span class="number">0</span>]-<span class="number">1</span>]])</span><br><span class="line">dst_points = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">500</span>, <span class="number">0</span>], [<span class="number">100</span>, <span class="number">500</span>], [<span class="number">400</span>, <span class="number">500</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算单应性矩阵</span></span><br><span class="line">H, _ = cv2.findHomography(src_points, dst_points)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透视变换</span></span><br><span class="line">warped_img = cv2.warpPerspective(img, H, (<span class="number">500</span>, <span class="number">500</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)), plt.title(<span class="string">&#x27;Original Image&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(cv2.cvtColor(warped_img, cv2.COLOR_BGR2RGB)), plt.title(<span class="string">&#x27;Warped Image&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="鱼眼模型">5. 鱼眼模型</h3>
<h4 id="原理-12">原理</h4>
<p>鱼眼镜头具有超广角，导致严重畸变。鱼眼模型通常使用等距投影或其他非线性投影，校正公式为： <span class="math display">\[ r_d = f \theta \]</span> 其中 <span class="math inline">\(\theta = \arctan(r_u / f)\)</span>，<span class="math inline">\(r_d\)</span> 和 <span class="math inline">\(r_u\)</span> 分别为畸变和未畸变半径。</p>
<h4 id="优缺点-12">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>能捕获超广角视野，适合全景成像。</li>
<li>校正后可用于 3D 重建。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>畸变严重，校正复杂。</li>
<li>边缘分辨率较低。</li>
</ul></li>
</ul>
<h4 id="适用条件-12">适用条件</h4>
<ul>
<li>适用于全景相机或监控系统。</li>
<li>适合需要超广角的场景。</li>
</ul>
<h4 id="python-opencv-代码-12">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取鱼眼图像</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;fisheye_image.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义内参和畸变系数</span></span><br><span class="line">K = np.array([[<span class="number">500</span>, <span class="number">0</span>, <span class="number">320</span>], [<span class="number">0</span>, <span class="number">500</span>, <span class="number">240</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">dist_coeffs = np.array([<span class="number">0.2</span>, <span class="number">0.02</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])  <span class="comment"># 鱼眼畸变系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 校正鱼眼畸变</span></span><br><span class="line">h, w = img.shape[:<span class="number">2</span>]</span><br><span class="line">mapx, mapy = cv2.initUndistortRectifyMap(K, dist_coeffs, <span class="literal">None</span>, K, (w, h), cv2.CV_32FC1)</span><br><span class="line">undistorted_img = cv2.remap(img, mapx, mapy, cv2.INTER_LINEAR)</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="立体视觉">6. 立体视觉</h3>
<h4 id="原理-13">原理</h4>
<p>立体视觉通过两台相机的视差计算场景深度。基本公式为： <span class="math display">\[ Z = \frac{f T}{d} \]</span> 其中： - <span class="math inline">\(Z\)</span>：深度。 - <span class="math inline">\(f\)</span>：焦距。 - <span class="math inline">\(T\)</span>：两相机基线距离。 - <span class="math inline">\(d\)</span>：视差（左图和右图对应点的水平偏移）。</p>
<h4 id="优缺点-13">优缺点</h4>
<ul>
<li><strong>优点</strong>：
<ul>
<li>能直接计算 3D 深度信息。</li>
<li>适用于机器人导航、3D 重建。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>对相机标定和匹配精度要求高。</li>
<li>计算复杂度高，实时性较差。</li>
</ul></li>
</ul>
<h4 id="适用条件-13">适用条件</h4>
<ul>
<li>适用于需要深度信息的场景，如自动驾驶、机器人。</li>
<li>适合纹理丰富的场景。</li>
</ul>
<h4 id="python-opencv-代码-13">Python + OpenCV 代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_left = cv2.imread(<span class="string">&#x27;left_image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">img_right = cv2.imread(<span class="string">&#x27;right_image.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建立体匹配对象</span></span><br><span class="line">stereo = cv2.StereoBM_create(numDisparities=<span class="number">16</span>, blockSize=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算视差图</span></span><br><span class="line">disparity = stereo.compute(img_left, img_right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化显示</span></span><br><span class="line">disparity = cv2.normalize(disparity, <span class="literal">None</span>, <span class="number">0</span>, <span class="number">255</span>, cv2.NORM_MINMAX).astype(np.uint8)</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="总结-1">总结</h2>
<h3 id="边缘提取算法对比">边缘提取算法对比</h3>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>抗噪性</th>
<th>边缘定位</th>
<th>计算复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Canny</td>
<td>高</td>
<td>高</td>
<td>中</td>
<td>高质量边缘检测</td>
</tr>
<tr class="even">
<td>Roberts</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>简单图像</td>
</tr>
<tr class="odd">
<td>Sobel</td>
<td>中</td>
<td>中</td>
<td>低</td>
<td>水平/垂直边缘</td>
</tr>
<tr class="even">
<td>Prewitt</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>简单图像</td>
</tr>
<tr class="odd">
<td>Hessian</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>线状结构</td>
</tr>
<tr class="even">
<td>Haar</td>
<td>中</td>
<td>低</td>
<td>低</td>
<td>目标检测</td>
</tr>
<tr class="odd">
<td>Laplacian</td>
<td>低</td>
<td>中</td>
<td>低</td>
<td>简单图像</td>
</tr>
<tr class="even">
<td>Scharr</td>
<td>中</td>
<td>高</td>
<td>低</td>
<td>高精度边缘</td>
</tr>
</tbody>
</table>
<h3 id="相机模型要点">相机模型要点</h3>
<ul>
<li><strong>小孔成像</strong>：理想模型，简单但不实用。</li>
<li><strong>相机模型</strong>：考虑内参外参，适合精确建模。</li>
<li><strong>镜头畸变</strong>：校正非理想透镜，广角镜头必备。</li>
<li><strong>透视变换</strong>：平面视角变换，适合校正和拼接。</li>
<li><strong>鱼眼模型</strong>：超广角成像，需复杂校正。</li>
<li><strong>立体视觉</strong>：深度计算，适合 3D 重建。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>cvlearning</tag>
      </tags>
  </entry>
</search>
